# `MySQL` 数据结构架构

`InnoDB` 存储引擎的数据结构包括内存数据结构和磁盘数据结构，如下图所示： 

![innodb-architecture.png](./assets/innodb-architecture.png)

## 一、内存结构

`InnoDB` 存储引擎的内存数据结构包括 `Buffer Pool`、`Change Buffer`、`Adaptive Hash Index` 和 `Log Buffer` 等。

### 1. Buffer Pool

当 `InnoDB` 存储引擎访问表或索引的数据时，会将这些数据缓存到主存的一块区域，这块区域被称作 `Buffer Pool`。Buffer Pool 允许那些经常被访问的数据能够直接从主存读取而不经过磁盘，这能加快数据的处理效率。在专用服务器上，通常会分配高达 80% 的物理内存给缓冲池。

了解如何利用缓冲池将频繁访问的数据保存在内存中是 `MySQL` 调优的一个重要方面。

为了提升读取大量数据的操作的效率，Buffer Pool 被划分为很多页（page），这些页可能容纳很多行数据。为了提高缓存管理的效率，Buffer Pool 整体上被实现为一条由很多页串起来的链表，同时使用 `LRU（Least Recently Used）算法` 进行缓存置换。

#### Buffer Pool 与 `LRU`

 `InnoDB` 使用 LRU 算法将 Buffer Pool 作为一条链表进行管理，当 Buffer Pool 容量不足时，最近最少被使用的的页将被驱逐出 Buffer Pool 链表，同时会将一个新的页加到 Buffer Pool 的新子链（new sublist）和旧子链（old sublist）的分界处。按我理解新子链里存放的热数据，可称为热区；旧子链存放的是待驱逐的页，可称为冷区。

![innodb-buffer-pool-list.png](./assets/innodb-buffer-pool-list.png)

这个算法使得经常被使用的页能留在新子链，而不常被访问的页将在旧子链中，旧子链中的页都是被驱逐的候选页。默认地，LRU 会如下作业：

- 3/8 的 Buffer Pool 将会划分为旧子链，5/8 的 Buffer Pool 被划分为新子链（热点数据）

- 列表的中点是新子链的尾部与旧子链的头部相交的边界

- 当 InnoDB 将一个页读入 Buffer Pool 时，会先将该页插到 Buffer Pool 的中点（旧子链的头部），这时该页能被读取到，因为它是用户指定的操作（如 SQL 查询）所必需的，或者是由 InnoDB  自动执行的预读操作的 一部分。

- 如果旧子链中的页被访问，那么它将变得年轻（young），这时会把它调到新子链的头部。这时还分情况： 如果因为用户需要而读取该页，则会立即进行第一次访问，并使页面变得年轻；如果由于预读而读取了页面，则第一次访问不会立即发生（并且在页面被逐出之前可能根本不会发生）。

  也就是说，如果是用户查询需要的数据，那么它很可能成为热点数据，但是如果只是预读需要，很可能这个数据并不会被实际需要，后面需要将之驱逐。

- 随着数据库的运行，一直没有被访问的数据页的年龄会逐渐地变大，同时在新旧子链中页面也会因为其他页面变得年轻而相对变老，另一方面，新读取的页面由于是插到旧子链的头部，所以其中的页面也会逐渐变老，最后，一直没被访问的页面会到达旧子链的尾部，最后被驱除出 Buffer Pool。

默认地，查询所需的页会在读到  Buffer Pool 的中点处后被移到新子链的头部，意味着相对来说它们可以在  Buffer Pool 中驻留久点。有些场景，比如执行 `mysqldump` 或者没有 WHERE 子句的 SELECT 操作，都会引发全表扫描 ，导致大量数据被缓存到  Buffer Pool 中，同时导致同样数量大的旧页被驱逐（假设缓存全部不命中），即使这部分缓存的新页很可能只是被访问一次。

同样地，由 InnoDB 后台线程预读的数据很可能也只是使用一次，但是它们都会被被陆续移到新子链的头部，导致真正的热点数据被刷掉。

#### Buffer Pool 热点数据集中失效问题如何解决

InnoDB 使用一种能够减少缓存到 Buffer Pool 而不会使用的数据的技术，而不是使用传统的 LRU。它的目标是确保即便遇到全表扫描或预读操作导致大量新数据块塞到 Buffer Pool  （这些数据后面再也没有被访问），那些经常被访问的热点页也能够保留在 Buffer Pool 中。

新插入的数据块会插到 Buffer Pool 的 “中点” 处，这个 “中点” 实际上是距离旧子链尾部往上 3/8 处，在该页第一次被读取时，LRU 算法会该页被插到整个 Buffer Pool 的头部，因此，对于传统的 LRU 算法而言，如果一个页一直没有被访问，那么它不可能出现在  Buffer Pool 的头部，随着缓存数据的变化，它将会老化并最终被淘汰。

你可以通过配置参数 `innodb_old_blocks_pct` 控制旧子链在整个 Buffer Pool 中所占用的比例，这个参数默认值是 37，对应我们上述的 3/8，这个参数往往在 5 到 95 之间，如果是 5，对于预读操作，这个数据很快就会老化并被淘汰；如果是 95，则只有 5% 的 Buffer Pool 用来存储热点数据，这样的算法近似传统的 LRU。

按我理解，将 `innodb_old_blocks_pct` 调得很小，从而控制冷区的空间在一个相对较小的范围，能解决预读大量无用数据的问题，但还是没解决全表查询的情况，因为默认地，这样的数据块很快就会被陆续移到新链头部，而新链放的就是热点数据，意味着热点数据还是会被刷掉。

对于全表查询，一个数据页通常被很快地访问几次（因为一页包含多行数据）然后便不会被访问了，这时可以使用另外一个叫 `innodb_old_blocks_time` 的参数，**用来指定第一次访问一个页后的时间窗口（以毫秒为单位），在这个时间窗口内，不管这个页被访问多少次，它都不会被移动到热区的顶端。** 这个参数的默认值是 1000，增大这个数值能够使得越来越多的页更快地从 Buffer Pool 中老化并被淘汰（因为延迟了它们进入热区的时间）。

`innodb_old_blocks_pct` 和 `innodb_old_blocks_time` 这两个参数都可以在配置文件 (`my.cnf` 或 `my.ini`) 中配置，或者通过 SET GLOBAL 语句进行设置。如果进行了设置后想要知道自己的设置是否生效，可以通过 `SHOW ENGINE INNODB STATUS` 命令查询当前 Buffer Pool 的情况。

由于这些参数的影响可能会根据硬件配置、数据和工作负载的细节的不同而发生很大的变化，所以在任何性能关键型或生产环境中更改这些设置之前，需要通过基准测试来验证有效性。

在混合工作负载中，大多数活动是 `OLTP` 类型的，这些活动往往伴随着列表查询，这样会导致大规模扫描，在批处理运行期间设置 `innodb_old_blocks_time` 的值可以帮助将正常工作负载的工作集保持在 Buffer Pool 中，则不刷走热区数据。

当扫描不能完全放入缓冲池的大表时，将 `innodb_old_blocks_pct` 设置为一个小值，可以避免只读取一次的数据占用缓冲池的大部分。例如，设置 `innodb_old_blocks_pct=5`，将只读取一次的数据限制为 Buffer Pool 的 5%。

当扫描小表时，如果能放到内存中，那么在 Buffer Pool 中移动页的开销会比较小，所以可以让这个值保持默认，或者可以把它调大点，比如设置 `innodb_old_blocks_pct=5`。

`innodb_old_blocks_time` 参数的影响比 `innodb_old_blocks_pct` 的更难预测，但它影响相对较小，而且这种影响会随着工作量的不同而变化，所以如果通过调整 `innodb_old_blocks_pct` 所带来的性能提升还不够，那么可以执行自己的基准测试来确定 `innodb_old_blocks_time` 的最佳值。

#### Buffer Pool 配置

可以通过调整参数来提升性能，详情见 Buffer Pool 的相关配置。

- 理想情况下，将缓冲池的大小设置为一个实用的尽可能大的值，这样服务器上的其他进程就有足够的内存运行，而不会出现过多的分页。缓冲池越大，InnoDB 就越像一个内存中的数据库，一次从磁盘读取数据，然后在后续读取时从内存中访问数据。
- 在 64 位系统中，为了减少并发操作带来的内存竞争，可以将 Buffer Pool 划分成多个实例，
- 为了避免大批量不经常访问的数据进入 Buffer Pool 后刷掉热数据，可以进行相应的配置解决。
- 因为 Buffer Pool 中的数据可能被修改而与磁盘不一致，所以需要刷盘，刷盘时可以控制后台刷新的时间以及是否根据工作负载动态调整刷新的速率。
- 可以配置 InnoDB 如何保持当前的 Buffer Pool 状态，以避免服务器重启后的漫长预热期。


#### Buffer Pool 监控

通过 `SHOW ENGINE INNODB STATUS` 命令可以看到 InnoDB 标准的监控输出，其中提供了一些关于 Buffer Pool 操作的指标。

```shell
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
```

下面是关于 Buffer Pool 的一些指标输出的描述：

|             Name             |                         Description                          |
| :--------------------------: | :----------------------------------------------------------: |
|    Total memory allocated    |         用于开辟 buffer pool 的内存大小，单位是字节          |
| Dictionary memory allocated  |        用于开辟 InnoDB 数据字典的内存大小，单位是字节        |
|       Buffer pool size       |                      buffer pool 总页数                      |
|         Free buffers         |              buffer pool 的 free list 的总页数               |
|        Database pages        |               buffer pool 的 LRU list 的总页数               |
|      Old database pages      |                    buffer pool 的冷区页数                    |
|      Modified db pages       |           buffer pool 中被修改的 LRU list 的总页数           |
|        Pending reads         |               buffer pool 中等待被读取的总页数               |
|      Pending writes LRU      |               old LRU list 底部待刷盘的脏页数                |
|  Pending writes flush list   |       checkpointing 期间 Buffer Pool 中待刷盘的总页数        |
|  Pending writes single page  | The number of pending independent page writes within the buffer pool.（看不懂） |
|       Pages made young       |                    等待被移到热区的总页数                    |
|     Pages made not young     |             保留在冷区没有变年轻（访问）的总页数             |
|           youngs/s           | 平均每秒访问 Buffer Pool 的 LRU list 的冷页并使冷页变热的次数 |
|         non-youngs/s         | 平均每秒访问 Buffer Pool 的 LRU list 的冷页但冷页不变热的次数 |
|          Pages read          |                从 buffer pool 读取到的总页数                 |
|        Pages created         |                 在 buffer pool 创建的总页数                  |
|        Pages written         |             从 buffer pool 写入（磁盘）的总页数              |
|           reads/s            |              每秒读取 Buffer Pool 页的平均次数               |
|          creates/s           |              每秒创建 Buffer Pool 页的平均次数               |
|           writes/s           |              每秒写入 Buffer Pool 页的平均次数               |
|     Buffer pool hit rate     | 从 Buffer Pool 读取页面与从磁盘存储读取页面的缓冲池页面命中率。 |
|      young-making rate       |               页面访问导致页变年轻的平均命中率               |
|   not (young-making rate)    |              页面访问不导致页变年轻的平均命中率              |
|       Pages read ahead       |                       平均每秒预读次数                       |
| Pages evicted without access |         buffer pool 中平均每秒因未被访问而被驱逐页数         |
|      Random read ahead       |                     平均每秒随机预读次数                     |
|           LRU len            |               buffer pool 中 LRU list 的总页数               |
|        unzip_LRU len         |          buffer pool 中 加压缩 的 LRU list 的总页数          |
|           I/O sum            |            buffer pool 中的 LRU list 被访问的页数            |
|           I/O cur            |                 LRU list 中当前被访问的页数                  |
|        I/O unzip sum         |                unzip_LRU list 解压缩的总页数                 |
|        I/O unzip cur         |           unzip_LRU list 当前时间段解压缩的总页数            |

在上面的参数中，可以重点关注下面这几个

- `youngs/s`：仅用于描述旧页，它基于访问页面的次数。一个给定页面可以有多次访问，所有访问都将被计算。young 表示被访问并且成为热区数据，即描述单位时间内，页被访问并且变 young 的次数。如果在没有大规模扫描的情况下会看到 young /s 是一个非常低的值，可以考虑减少冷区页变热的延时时间或者增大冷区在整个 Buffer Pool 的 LRU list 中的比例，从而使该冷区中的页移动到尾部需要更长的时间，这能增加再次访问这些页并使其变为年轻页的可能性（因为没有全表扫描，这些页很可能被再次访问）。
- `non-youngs/s`：仅用于描述旧页，它基于访问页面的次数。一个给定页面可以有多次访问，所有访问都将被计算。non-young 表示被访问但是不会成为热区数据（因为设置了 `innodb_old_blocks_time`），即描述单位时间内，页被访问但没变 young 的次数。如果这个数值很高，一般情况下是因为系统存在严重的全表扫描，并且 `innodb_old_blocks_time` 设置得足够大。反过来，如果你正在执行全表扫描，但是没有看到这个值变大，或者看到 `youngs/s` 变大，说明延时设置不够大，可能会把大量热区数据刷掉，所以要把 `innodb_old_blocks_time` 调大。
- `young-making rate`：表示了 Buffer Pool 中所有页变年轻的访问次数，而不仅仅是冷区页，`young-making rate `和 `not (young-making rate)` 加起来不一定等于整个 Buffer Pool 的命中率，冷区页的命中会导致页面移至热区，但是热区页的命中只有在页本身与热区头部间有一定距离才会移至热区头部（即如果命中本身就是热区头部将不会变年轻吗？）
-  `not (young-making rate)` ：同样表示 Buffer Pool 中所有页的访问情况，而不仅局限于冷区页。由于设置了 `innodb_old_blocks_time` ，所以这时对冷区页的访问并不会使它们变年轻而移到热区，这个参数就表示这种访问的比例，当然热区数据被访问也不一定移到热区头部（类似上一个参数？命中本身就是热区头部？）

### 2. Change Buffer

Change Buffer 是一种特殊的数据结构，用于在二级索引页不在 Buffer Pool 中时将对二级索引页更改缓存起来。Change Buffer 中记录的索引页变更，可能由 INSERT，UPDATE 或 DELETE 操作（DML）导致，如果在以后有其他读取操作将相应的索引页加载到 Buffer Pool 时，Change Buffer 中的数据将会与之合并。

![innodb-change-buffer.png](./assets/innodb-change-buffer.png)

与聚集索引不同，二级索引通常是非唯一的，意味着连续两次写入很可能是不连续的，即向二级索引插入的顺序相对随机。类似地，删除和更新可能会影响不在索引树中相邻位置的二级索引页。所以如果对二级索引数据进行修改时，先将修改写入 Change Buffer，此后，当其他操作将受影响的页读入 Buffer Pool 时，再将 Change Buffer 中缓存的更改合并到 Buffer Pool，这样可以避免从磁盘将二级索引页面读入 Buffer Pool 所带来的大量的随机 I/O 访问。

当系统大部分资源处于闲置状态或正在缓慢关闭时，会运行 purge 操作，这将修改了的索引页刷新到磁盘中去，以使得缓存与磁盘数据同步。与将每个值立即写入磁盘相比，使用 Change Buffer 和 Purge 操作，能够更高效地写入一系列的被更改的索引页。

当有许多受影响的行和许多需要更新的索引页时，合并 Change Buffer 可能需要几个小时。在此期间，磁盘 I/O 会增加，这可能会导致需要查磁盘的查询显著放缓。合并 Change Buffer 也可能在事务提交之后，甚至在服务器关闭和重启之后继续发生。

在内存中， Change Buffer 占用部分 Buffer Pool。在磁盘上，Change Buffer 是系统表空间（System Tablespace）的一部分，当数据库服务器关闭时，对索引更改将被缓冲到该表空间中。

如果二级索引包含降序索引列，或者主键包含降序索引列，则不支持更改缓冲。

#### 配置 Change Buffer 启停

当在表上执行插入、更新和删除操作时，索引列的值（特别是辅助索引上的值）通常是无序的，这需要大量的 I/O 来更新辅助索引。当相关页不在缓冲池中时，会先将二级索引项缓存到 Change Buffer，从而避免了昂贵的 I/O 操作，因为没有立即从磁盘读取该页。当页面加载到 Buffer Pool 时，将合并缓冲的更改，并且稍后将更新的页面刷新到磁盘。InnoDB 的主线程会在服务器几乎空闲的时候，或者在缓慢关机的时候合并 Change Buffer 中的数据到 Buffer Pool。

因为 Change Buffer 机制可以减少磁盘读写，它对于 I/O 绑定的工作负载最有价值，例如，具有大量 DML 操作（如批量插入）的应用程序可以从 Change Buffer 中受益。

然而，Change Buffer 占用了缓冲池的一部分，减少了可用来缓存数据页的内存。如果工作集几乎适合 Buffer Pool，或者表的二级索引相对较少，那么需要考虑禁用 Change Buffering。如果工作数据集完全适合 Buffer Pool，则 Change Buffer 不会带来额外的开销，因为它只适用于不在 Buffer Pool 中的页面。

参数 `innodb_change_buffering` 控制 InnoDB 执行 Change Buffer 的程度。可以为插入、删除操作（当索引记录最初被标记为删除时）和清除操作（当索引记录被物理删除时）启用或禁用缓冲。更新操作是插入和删除操作的组合。`innodb_change_buffering` 的默认值是 `all`。

- `all`：默认值，缓冲区插入、标记删除和清除操作都会缓存到 Change Buffer。
- `none`：任何操作都不缓存
- `inserts`：缓存插入操作影响的索引页
- `deletes`：缓存标记删除操作影响的索引页
- `changes`：缓存插入和标记删除操作影响的索引页
- `purges`：缓存后台运行的清除物理数据操作影响的索引页

可以通过配置文件（my.conf 或 my.ini）对该参数进行设置，或者通过 `SET GLOBAL` 命令进行动态设置。改变设置会影响新操作的缓冲，现有缓冲项的合并不受影响。

#### 配置 Change Buffer 的大小

变量 `innodb_change_buffer_max_size` 用来控制 Change Buffer 的最大大小占 Buffer Pool 总大小的百分比。默认情况下，`innodb_change_buffer_max_size` 设置为 25。最大设置为 50。

如果 MySQL 服务器的更新、插入操作很频繁，这时 Change Buffer 的合并速度很可能会跟不上往 Change Buffer 写入数据的速度，这时可以考虑增大这个参数值；如果 MySQL 服务器存储的大多是静态报表数据，或者由于 Change Buffer 在 Buffer Pool 中所占比例过高而导致页面比预期的更早老化出 Buffer Pool。

使用具有代表性的工作负载测试不同的设置，以确定最佳配置。`innodb_change_buffer_max_size` 变量是动态的，允许在不重启服务器的情况下修改设置。

#### 监控 Change Buffer

##### 1. 看标准监控输出

`InnoDB` 标准的监视器输出包含了 Change Buffer 的信息，可以通过 `SHOW ENGINE INNODB STATUS\G` 命令查看，Change Buffer 的状态信息在 `INSERT BUFFER AND ADAPTIVE HASH INDEX` 头信息下面：

```shell
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
13577.57 hash searches/s, 202.47 non-hash searches/s
```

##### 2. 通过元数据表

`INFORMATION_SCHEMA.INNODB_METRICS` 表里提供了在 `InnoDB` 标准监视器输出中找到的大多数数据点以及其他数据点，可通过如下命令查询：

```mysql
mysql> SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G
```

`INFORMATION_SCHEMA.INNODB_BUFFER_PAGE` 表提供了有关 Buffer Pool 中每个页的元数据，包括 Change Buffer 索引和 Change Buffer 位图页。Change Buffer 页由 `PAGE_TYPE` 标识。`IBUF_INDEX` 是 Change Buffer 索引页面的类型，`IBUF_BITMAP`  的页面是 Change Buffer 位图页的页面类型。

> 查询 `INNODB_BUFFER_PAGE` 表可能会带来很大的性能开销。为避免影响性能，需要重现要在测试实例上调查的问题，然后在测试实例上运行查询。

例如，你可以查询 `INNODB_BUFFER_PAGE` 表中 `IBUF_INDEX` 和`IBUF_BITMAP` 的数量以确定它们在 Buffer Pool 页面总数中的比例。

```mysql
mysql> SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
       WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages,
       (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages,
       (SELECT ((change_buffer_pages/total_pages)*100))
       AS change_buffer_page_percentage;
+---------------------+-------------+-------------------------------+
| change_buffer_pages | total_pages | change_buffer_page_percentage |
+---------------------+-------------+-------------------------------+
|                  25 |        8192 |                        0.3052 |
+---------------------+-------------+-------------------------------+
```

Performance Schema 提供 Change Buffer 互斥锁等待检测，以进行高级性能监视。要查看 Change Buffer 检测情况，可如下查询：

```mysql
mysql> SELECT * FROM performance_schema.setup_instruments
       WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |
+-------------------------------------------------------+---------+-------+
```

### 3. 自适应哈希索引

自适应哈希索引使 `InnoDB` 可在不牺牲事务功能或可靠性的情况下，在工作负载和 Buffer Pool 适当的系统上，更像是内存数据库。自适应哈希索引由 `innodb_adaptive_hash_index` 参数控制，如果想在 MySQL 服务器启动时禁用它，可以加上 `--skip-innodb-adaptive-hash-index` 启动参数。

根据观察到的搜索模式，使用索引建的前缀构建哈希索引。前缀可以是任何长度，因此这可能导致在哈希索引上出现的值是 B 树上的某部分。哈希索引是根据对经常访问的索引页面的需求而建立的。

如果表几乎完全适合主内存，则哈希索引通过启用直接查找元素并将索引值转变为某种指针来加快查询速度。 `InnoDB `具有监视索引搜索的机制。如果 `InnoDB` 发现查询可以从构建哈希索引中受益，它会自动这样做。

在某些工作负载下，哈希索引查找的速度的提升带来的收益大大超过了监视索引查找和维护哈希索引结构的额外工作的付出。在繁重的工作负载（例如多个并发联表查询）下，访问自适应哈希索引有时可能会成为并发竞争的资源。带有 `LIKE` 运算符和 `%` 通配符的查询也往往不会受益。对于无法从自适应哈希索引中受益的工作负载，将其关闭以减少不必要的性能开销。由于很难预先预测自适应哈希索引功能是否适合特定的系统和工作负载，因此请考虑在启用和禁用该功能的情况下运行基准测试。

在 MySQL 5.7 中，自适应哈希索引功能已分区。每个索引都绑定到特定分区，并且每个分区均受单独的锁存器（latch）保护（分段锁）。分区由 `innodb_adaptive_hash_index_parts` 变量控制 。在较早的版本中，自适应哈希索引功能受单个闩锁的保护，在繁重的工作负载下，该闩锁可能成为争用点。该 `innodb_adaptive_hash_index_parts` 变量默认设置为 8。最大设置为 512。

通过 `SHOW ENGINE INNODB STATUS` 的监视器输出，可以看到自适应哈希索引的使用和竞争情况，如果有大量的线程等待 `btr0sea.c` 中创建的读写锁（rw-latches），那么需要考虑增大  `innodb_adaptive_hash_index_parts` 的值，或者禁用自适应哈希索引。

想看更多关于哈希索引的特性，访问 [B-树索引和哈希索引的比较](https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html)。

### 4. Log Buffer

Log Buffer 是用于保存要写入磁盘上的日志文件的数据的内存区域，它的大小由 `innodb_log_buffer_size` 配置参数控制，默认是 16 MB。Log Buffer 的内容会定期刷新到磁盘。由于 Log Buffer 的存在使大型事务得以运行，而无需在事务提交之前将 redo log 数据写入磁盘。因此，如果有更新，插入或删除许多行的事务，则增加日志缓冲区的大小可以节省磁盘 I/O。

## 二、磁盘数据结构

`InnoDB` 的磁盘数据结构包括表、索引、`Tablespace`、`InnoDB Data Dictionary`、`Doublewrite Buffer`、`Redo Log` 和 `Undo Logs`。

### 2. 索引

#### 2.1 聚簇索引和二级索引

每个 `InnoDB` 表都有一个特殊的索引，称为聚簇索引，用于存储行数据。通常，聚簇索引与主键同义。为了从查询，插入和其他数据库操作中获得最佳性能，重要的是要了解 `InnoDB` 如何使用聚簇索引来优化通用查找和 DML 操作的。

- 当你在一张表上定义 `PRIMARY KEY` 的时候，`InnoDB` 会将之作为一个聚簇索引。每个表都应该定义一个主键。如果没有逻辑唯一（UNIQUE）且非空（non-null）的列或使用主键的列集，请额外添加一个自增长的（auto-increment）列。自增长列的数据是唯一的，当插入一个新的行时其值会自动增加。
- 如果你没有为一张表定义 `PRIMARY KEY`，`InnoDB` 会使用第一个带有全非空列的唯一（UNIQUE）索引作为聚簇索引（因为唯一索引可能是单/多列联合索引，此处按我理解要求索引每个列都必须为 non-null）。
- 如果没有满足上述两点的索引，`InnoDB` 将会生成一个名为 `GEN_CLUST_INDEX` 的索引，这个索引加在一个隐藏的列上，这个列包含行标识（row ID）。`InnoDB` 为数据行分配了一个 6 字节大小的 row ID 字段，数据行按照这个 row ID 进行排序，row ID 随着插入新行而单调增加。因此，按 row ID 排序的行实际上是按插入顺序排列的。

##### 聚集索引如何加快查询速度

通过聚簇索引访问行数据是非常快的，因为在索引中搜索数据会直接指向包含行数据的页（指针）。如果一个表很大，而不使用这种索引记录着页的组织方式的话，那么将会需要耗费很大的磁盘 I/O，

##### 二级索引与聚簇索引是怎么关联的

除聚簇索引以外的索引称为二级索引。在 `InnoDB`，辅助索引中的每个记录都包含该行的主键列以及为辅助索引指定的列。`InnoDB` 使用此主键值在聚集索引中搜索行。如果主键较长，则辅助索引将使用更多空间，因此容量小的主键能节省二级索引的空间。

#### 2.2 InnoDB 索引的物理结构

除空间索引外，InnoDB 索引都是 B+ 树结构，空间索引使用 R 树结构，R 树是用于索引多维数据的专用数据结构。索引记录存储在其 B 树或 R 树数据结构的叶页中。索引页的默认大小为 16 KB。 索引页的大小由参数 `innodb_page_size` 控制。

当往 InnoDB 的聚簇索引中插入新的记录时，InnoDB 会尝试留下 1/16 的页空间，以备后面插入或更新所需。如果索引的记录集是以升序或降序排列，则最后索引页将占满 15/16。如果是以随机顺序插入记录的，则页面的容量为 1/2 到 15/16。

InnoDB 在创建或重建 B 树索引时执行批量加载。这种索引创建方法称为`排序索引构建`。为了给以后索引增长提供空间，用  `innodb_fill_factor` 变量定义填充索引页的比例（例如填充到 90% 就不插入了）。空间索引不支持这种 `排序索引构建`。 innodb_fill_factor 定义成 100 时将会留下 1/16 的空闲聚簇索引为将来扩展时使用，

如果 InnoDB 索引页的填充因子低于 MERGE_THRESHOLD （默认情况下为 50％），则（当容量超过时） InnoDB 尝试压缩索引树以释放空间。MERGE_THRESHOLD  参数适用于 B树 索引和 R 树索引。

### 3. redo log
