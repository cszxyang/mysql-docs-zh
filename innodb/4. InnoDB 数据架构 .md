# `MySQL` 数据结构架构

`InnoDB` 存储引擎的数据结构包括内存数据结构和磁盘数据结构，如下图所示： 

![innodb-architecture.png](./assets/innodb-architecture.png)

## 一、内存结构

`InnoDB` 存储引擎的内存数据结构包括 `Buffer Pool`、`Change Buffer`、`Adaptive Hash Index` 和 `Log Buffer` 等。

### 1. Buffer Pool

当 `InnoDB` 存储引擎访问表或索引的数据时，会将这些数据缓存到主存的一块区域，这块区域被称作 `Buffer Pool`。Buffer Pool 允许那些经常被访问的数据能够直接从主存读取而不经过磁盘，这能加快数据的处理效率。在专用服务器上，通常会分配高达 80% 的物理内存给缓冲池。

了解如何利用缓冲池将频繁访问的数据保存在内存中是 `MySQL` 调优的一个重要方面。

为了提升读取大量数据的操作的效率，Buffer Pool 被划分为很多页（page），这些页可能容纳很多行数据。为了提高缓存管理的效率，Buffer Pool 整体上被实现为一条由很多页串起来的链表，同时使用 `LRU（Least Recently Used）算法` 进行缓存置换。

#### Buffer Pool 与 `LRU`

 `InnoDB` 使用 LRU 算法将 Buffer Pool 作为一条链表进行管理，当 Buffer Pool 容量不足时，最近最少被使用的的页将被驱逐出 Buffer Pool 链表，同时会将一个新的页加到 Buffer Pool 的新子链（new sublist）和旧子链（old sublist）的分界处。按我理解新子链里存放的热数据，可称为热区；旧子链存放的是待驱逐的页，可称为冷区。

![innodb-buffer-pool-list.png](./assets/innodb-buffer-pool-list.png)

这个算法使得经常被使用的页能留在新子链，而不常被访问的页将在旧子链中，旧子链中的页都是被驱逐的候选页。默认地，LRU 会如下作业：

- 3/8 的 Buffer Pool 将会划分为旧子链，5/8 的 Buffer Pool 被划分为新子链（热点数据）

- 列表的中点是新子链的尾部与旧子链的头部相交的边界

- 当 InnoDB 将一个页读入 Buffer Pool 时，会先将该页插到 Buffer Pool 的中点（旧子链的头部），这时该页能被读取到，因为它是用户指定的操作（如 SQL 查询）所必需的，或者是由 InnoDB  自动执行的预读操作的 一部分。

- 如果旧子链中的页被访问，那么它将变得年轻（young），这时会把它调到新子链的头部。这时还分情况： 如果因为用户需要而读取该页，则会立即进行第一次访问，并使页面变得年轻；如果由于预读而读取了页面，则第一次访问不会立即发生（并且在页面被逐出之前可能根本不会发生）。

  也就是说，如果是用户查询需要的数据，那么它很可能成为热点数据，但是如果只是预读需要，很可能这个数据并不会被实际需要，后面需要将之驱逐。

- 随着数据库的运行，一直没有被访问的数据页的年龄会逐渐地变大，同时在新旧子链中页面也会因为其他页面变得年轻而相对变老，另一方面，新读取的页面由于是插到旧子链的头部，所以其中的页面也会逐渐变老，最后，一直没被访问的页面会到达旧子链的尾部，最后被驱除出 Buffer Pool。

默认地，查询所需的页会在读到  Buffer Pool 的中点处后被移到新子链的头部，意味着相对来说它们可以在  Buffer Pool 中驻留久点。有些场景，比如执行 `mysqldump` 或者没有 WHERE 子句的 SELECT 操作，都会引发全表扫描 ，导致大量数据被缓存到  Buffer Pool 中，同时导致同样数量大的旧页被驱逐（假设缓存全部不命中），即使这部分缓存的新页很可能只是被访问一次。

同样地，由 InnoDB 后台线程预读的数据很可能也只是使用一次，但是它们都会被被陆续移到新子链的头部，导致真正的热点数据被刷掉。

#### Buffer Pool 热点数据集中失效问题如何解决

InnoDB 使用一种能够减少缓存到 Buffer Pool 而不会使用的数据的技术，而不是使用传统的 LRU。它的目标是确保即便遇到全表扫描或预读操作导致大量新数据块塞到 Buffer Pool  （这些数据后面再也没有被访问），那些经常被访问的热点页也能够保留在 Buffer Pool 中。

新插入的数据块会插到 Buffer Pool 的 “中点” 处，这个 “中点” 实际上是距离旧子链尾部往上 3/8 处，在该页第一次被读取时，LRU 算法会该页被插到整个 Buffer Pool 的头部，因此，对于传统的 LRU 算法而言，如果一个页一直没有被访问，那么它不可能出现在  Buffer Pool 的头部，随着缓存数据的变化，它将会老化并最终被淘汰。

你可以通过配置参数 `innodb_old_blocks_pct` 控制旧子链在整个 Buffer Pool 中所占用的比例，这个参数默认值是 37，对应我们上述的 3/8，这个参数往往在 5 到 95 之间，如果是 5，对于预读操作，这个数据很快就会老化并被淘汰；如果是 95，则只有 5% 的 Buffer Pool 用来存储热点数据，这样的算法近似传统的 LRU。

按我理解，将 `innodb_old_blocks_pct` 调得很小，从而控制冷区的空间在一个相对较小的范围，能解决预读大量无用数据的问题，但还是没解决全表查询的情况，因为默认地，这样的数据块很快就会被陆续移到新链头部，而新链放的就是热点数据，意味着热点数据还是会被刷掉。

对于全表查询，一个数据页通常被很快地访问几次（因为一页包含多行数据）然后便不会被访问了，这时可以使用另外一个叫 `innodb_old_blocks_time` 的参数，**用来指定第一次访问一个页后的时间窗口（以毫秒为单位），在这个时间窗口内，不管这个页被访问多少次，它都不会被移动到热区的顶端。** 这个参数的默认值是 1000，增大这个数值能够使得越来越多的页更快地从 Buffer Pool 中老化并被淘汰（因为延迟了它们进入热区的时间）。

`innodb_old_blocks_pct` 和 `innodb_old_blocks_time` 这两个参数都可以在配置文件 (`my.cnf` 或 `my.ini`) 中配置，或者通过 SET GLOBAL 语句进行设置。如果进行了设置后想要知道自己的设置是否生效，可以通过 `SHOW ENGINE INNODB STATUS` 命令查询当前 Buffer Pool 的情况。

由于这些参数的影响可能会根据硬件配置、数据和工作负载的细节的不同而发生很大的变化，所以在任何性能关键型或生产环境中更改这些设置之前，需要通过基准测试来验证有效性。

在混合工作负载中，大多数活动是 `OLTP` 类型的，这些活动往往伴随着列表查询，这样会导致大规模扫描，在批处理运行期间设置 `innodb_old_blocks_time` 的值可以帮助将正常工作负载的工作集保持在 Buffer Pool 中，则不刷走热区数据。

当扫描不能完全放入缓冲池的大表时，将 `innodb_old_blocks_pct` 设置为一个小值，可以避免只读取一次的数据占用缓冲池的大部分。例如，设置 `innodb_old_blocks_pct=5`，将只读取一次的数据限制为 Buffer Pool 的 5%。

当扫描小表时，如果能放到内存中，那么在 Buffer Pool 中移动页的开销会比较小，所以可以让这个值保持默认，或者可以把它调大点，比如设置 `innodb_old_blocks_pct=5`。

`innodb_old_blocks_time` 参数的影响比 `innodb_old_blocks_pct` 的更难预测，但它影响相对较小，而且这种影响会随着工作量的不同而变化，所以如果通过调整 `innodb_old_blocks_pct` 所带来的性能提升还不够，那么可以执行自己的基准测试来确定 `innodb_old_blocks_time` 的最佳值。

#### Buffer Pool 配置

可以通过调整参数来提升性能，详情见 Buffer Pool 的相关配置。

- 理想情况下，将缓冲池的大小设置为一个实用的尽可能大的值，这样服务器上的其他进程就有足够的内存运行，而不会出现过多的分页。缓冲池越大，InnoDB 就越像一个内存中的数据库，一次从磁盘读取数据，然后在后续读取时从内存中访问数据。
- 在 64 位系统中，为了减少并发操作带来的内存竞争，可以将 Buffer Pool 划分成多个实例，
- 为了避免大批量不经常访问的数据进入 Buffer Pool 后刷掉热数据，可以进行相应的配置解决。
- 因为 Buffer Pool 中的数据可能被修改而与磁盘不一致，所以需要刷盘，刷盘时可以控制后台刷新的时间以及是否根据工作负载动态调整刷新的速率。
- 可以配置 InnoDB 如何保持当前的 Buffer Pool 状态，以避免服务器重启后的漫长预热期。


#### Buffer Pool 监控

通过 `SHOW ENGINE INNODB STATUS` 命令可以看到 InnoDB 标准的监控输出，其中提供了一些关于 Buffer Pool 操作的指标。

```shell
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
```

下面是关于 Buffer Pool 的一些指标输出的描述：

|             Name             |                         Description                          |
| :--------------------------: | :----------------------------------------------------------: |
|    Total memory allocated    |         用于开辟 buffer pool 的内存大小，单位是字节          |
| Dictionary memory allocated  |        用于开辟 InnoDB 数据字典的内存大小，单位是字节        |
|       Buffer pool size       |                      buffer pool 总页数                      |
|         Free buffers         |              buffer pool 的 free list 的总页数               |
|        Database pages        |               buffer pool 的 LRU list 的总页数               |
|      Old database pages      |                    buffer pool 的冷区页数                    |
|      Modified db pages       |           buffer pool 中被修改的 LRU list 的总页数           |
|        Pending reads         |               buffer pool 中等待被读取的总页数               |
|      Pending writes LRU      |               old LRU list 底部待刷盘的脏页数                |
|  Pending writes flush list   |       checkpointing 期间 Buffer Pool 中待刷盘的总页数        |
|  Pending writes single page  | The number of pending independent page writes within the buffer pool.（看不懂） |
|       Pages made young       |                    等待被移到热区的总页数                    |
|     Pages made not young     |             保留在冷区没有变年轻（访问）的总页数             |
|           youngs/s           | 平均每秒访问 Buffer Pool 的 LRU list 的冷页并使冷页变热的次数 |
|         non-youngs/s         | 平均每秒访问 Buffer Pool 的 LRU list 的冷页但冷页不变热的次数 |
|          Pages read          |                从 buffer pool 读取到的总页数                 |
|        Pages created         |                 在 buffer pool 创建的总页数                  |
|        Pages written         |             从 buffer pool 写入（磁盘）的总页数              |
|           reads/s            |              每秒读取 Buffer Pool 页的平均次数               |
|          creates/s           |              每秒创建 Buffer Pool 页的平均次数               |
|           writes/s           |              每秒写入 Buffer Pool 页的平均次数               |
|     Buffer pool hit rate     | 从 Buffer Pool 读取页面与从磁盘存储读取页面的缓冲池页面命中率。 |
|      young-making rate       |               页面访问导致页变年轻的平均命中率               |
|   not (young-making rate)    |              页面访问不导致页变年轻的平均命中率              |
|       Pages read ahead       |                       平均每秒预读次数                       |
| Pages evicted without access |         buffer pool 中平均每秒因未被访问而被驱逐页数         |
|      Random read ahead       |                     平均每秒随机预读次数                     |
|           LRU len            |               buffer pool 中 LRU list 的总页数               |
|        unzip_LRU len         |          buffer pool 中 加压缩 的 LRU list 的总页数          |
|           I/O sum            |            buffer pool 中的 LRU list 被访问的页数            |
|           I/O cur            |                 LRU list 中当前被访问的页数                  |
|        I/O unzip sum         |                unzip_LRU list 解压缩的总页数                 |
|        I/O unzip cur         |           unzip_LRU list 当前时间段解压缩的总页数            |

在上面的参数中，可以重点关注下面这几个

- `youngs/s`：仅用于描述旧页，它基于访问页面的次数。一个给定页面可以有多次访问，所有访问都将被计算。young 表示被访问并且成为热区数据，即描述单位时间内，页被访问并且变 young 的次数。如果在没有大规模扫描的情况下会看到 young /s 是一个非常低的值，可以考虑减少冷区页变热的延时时间或者增大冷区在整个 Buffer Pool 的 LRU list 中的比例，从而使该冷区中的页移动到尾部需要更长的时间，这能增加再次访问这些页并使其变为年轻页的可能性（因为没有全表扫描，这些页很可能被再次访问）。
- `non-youngs/s`：仅用于描述旧页，它基于访问页面的次数。一个给定页面可以有多次访问，所有访问都将被计算。non-young 表示被访问但是不会成为热区数据（因为设置了 `innodb_old_blocks_time`），即描述单位时间内，页被访问但没变 young 的次数。如果这个数值很高，一般情况下是因为系统存在严重的全表扫描，并且 `innodb_old_blocks_time` 设置得足够大。反过来，如果你正在执行全表扫描，但是没有看到这个值变大，或者看到 `youngs/s` 变大，说明延时设置不够大，可能会把大量热区数据刷掉，所以要把 `innodb_old_blocks_time` 调大。
- `young-making rate`：表示了 Buffer Pool 中所有页变年轻的访问次数，而不仅仅是冷区页，`young-making rate `和 `not (young-making rate)` 加起来不一定等于整个 Buffer Pool 的命中率，冷区页的命中会导致页面移至热区，但是热区页的命中只有在页本身与热区头部间有一定距离才会移至热区头部（即如果命中本身就是热区头部将不会变年轻吗？）
-  `not (young-making rate)` ：同样表示 Buffer Pool 中所有页的访问情况，而不仅局限于冷区页。由于设置了 `innodb_old_blocks_time` ，所以这时对冷区页的访问并不会使它们变年轻而移到热区，这个参数就表示这种访问的比例，当然热区数据被访问也不一定移到热区头部（类似上一个参数？命中本身就是热区头部？）

### 2. Change Buffer

Change Buffer 是一种特殊的数据结构，用于在二级索引页不在 Buffer Pool 中时将对二级索引页更改缓存起来。Change Buffer 中记录的索引页变更，可能由 INSERT，UPDATE 或 DELETE 操作（DML）导致，如果在以后有其他读取操作将相应的索引页加载到 Buffer Pool 时，Change Buffer 中的数据将会与之合并。

![innodb-change-buffer.png](./assets/innodb-change-buffer.png)

不同于聚簇索引，二级索引通常都是非唯一的，往二级索引插入页的顺序是随机的，同样地，删除和更新会影响不相邻的二级索引页 q



### 3. 自适应哈希索引

自适应哈希索引使 `InnoDB` 可在不牺牲事务功能或可靠性的情况下，在工作负载和 Buffer Pool 适当的系统上，更像是内存数据库。自适应哈希索引由 `innodb_adaptive_hash_index` 参数控制，如果想在 MySQL 服务器启动时禁用它，可以加上 `--skip-innodb-adaptive-hash-index` 启动参数。

根据观察到的搜索模式，使用索引建的前缀构建哈希索引。前缀可以是任何长度，因此这可能导致在哈希索引上出现的值是 B 树上的某部分。哈希索引是根据对经常访问的索引页面的需求而建立的。

如果表几乎完全适合主内存，则哈希索引通过启用直接查找元素并将索引值转变为某种指针来加快查询速度。 `InnoDB `具有监视索引搜索的机制。如果 `InnoDB` 发现查询可以从构建哈希索引中受益，它会自动这样做。

在某些工作负载下，哈希索引查找的速度的提升带来的收益大大超过了监视索引查找和维护哈希索引结构的额外工作的付出。在繁重的工作负载（例如多个并发联表查询）下，访问自适应哈希索引有时可能会成为并发竞争的资源。带有 `LIKE` 运算符和 `%` 通配符的查询也往往不会受益。对于无法从自适应哈希索引中受益的工作负载，将其关闭以减少不必要的性能开销。由于很难预先预测自适应哈希索引功能是否适合特定的系统和工作负载，因此请考虑在启用和禁用该功能的情况下运行基准测试。

在 MySQL 5.7 中，自适应哈希索引功能已分区。每个索引都绑定到特定分区，并且每个分区均受单独的锁存器（latch）保护（分段锁）。分区由 `innodb_adaptive_hash_index_parts` 变量控制 。在较早的版本中，自适应哈希索引功能受单个闩锁的保护，在繁重的工作负载下，该闩锁可能成为争用点。该 `innodb_adaptive_hash_index_parts` 变量默认设置为 8。最大设置为 512。

通过 `SHOW ENGINE INNODB STATUS` 的监视器输出，可以看到自适应哈希索引的使用和竞争情况，如果有大量的线程等待 `btr0sea.c` 中创建的读写锁（rw-latches），那么需要考虑增大  `innodb_adaptive_hash_index_parts` 的值，或者禁用自适应哈希索引。

想看更多关于哈希索引的特性，访问 [B-树索引和哈希索引的比较](https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html)。

### 4. Log Buffer

Log Buffer 是用于保存要写入磁盘上的日志文件的数据的内存区域，它的大小由 `innodb_log_buffer_size` 配置参数控制，默认是 16 MB。Log Buffer 的内容会定期刷新到磁盘。由于 Log Buffer 的存在使大型事务得以运行，而无需在事务提交之前将 redo log 数据写入磁盘。因此，如果有更新，插入或删除许多行的事务，则增加日志缓冲区的大小可以节省磁盘 I/O。

## 二、磁盘数据结构

`InnoDB` 的磁盘数据结构包括表、索引、`Tablespace`、`InnoDB Data Dictionary`、`Doublewrite Buffer`、`Redo Log` 和 `Undo Logs`。

### 2. 索引

#### 2.1 聚簇索引和二级索引

每个 `InnoDB` 表都有一个特殊的索引，称为聚簇索引，用于存储行数据。通常，聚簇索引与主键同义。为了从查询，插入和其他数据库操作中获得最佳性能，重要的是要了解 `InnoDB` 如何使用聚簇索引来优化通用查找和 DML 操作的。

- 当你在一张表上定义 `PRIMARY KEY` 的时候，`InnoDB` 会将之作为一个聚簇索引。每个表都应该定义一个主键。如果没有逻辑唯一（UNIQUE）且非空（non-null）的列或使用主键的列集，请额外添加一个自增长的（auto-increment）列。自增长列的数据是唯一的，当插入一个新的行时其值会自动增加。
- 如果你没有为一张表定义 `PRIMARY KEY`，`InnoDB` 会使用第一个带有全非空列的唯一（UNIQUE）索引作为聚簇索引（因为唯一索引可能是单/多列联合索引，此处按我理解要求索引每个列都必须为 non-null）。
- 如果没有满足上述两点的索引，`InnoDB` 将会生成一个名为 `GEN_CLUST_INDEX` 的索引，这个索引加在一个隐藏的列上，这个列包含行标识（row ID）。`InnoDB` 为数据行分配了一个 6 字节大小的 row ID 字段，数据行按照这个 row ID 进行排序，row ID 随着插入新行而单调增加。因此，按 row ID 排序的行实际上是按插入顺序排列的。

#### 2.2 聚集索引如何加快查询速度

通过聚簇索引访问行数据是非常快的，因为在索引中搜索数据会直接指向包含行数据的页（指针）。如果一个表很大，而不使用这种索引记录着页的组织方式的话，那么将会需要耗费很大的磁盘 I/O，

#### 2.3 二级索引与聚簇索引是怎么关联的

除聚簇索引以外的索引称为二级索引。在 `InnoDB`，辅助索引中的每个记录都包含该行的主键列以及为辅助索引指定的列。`InnoDB` 使用此主键值在聚集索引中搜索行。如果主键较长，则辅助索引将使用更多空间，因此容量小的主键能节省二级索引的空间。