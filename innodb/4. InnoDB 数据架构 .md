# `MySQL` 数据结构架构

`InnoDB` 存储引擎的数据结构包括内存数据结构和磁盘数据结构，如下图所示： 

![innodb-architecture.png](./assets/innodb-architecture.png)

## 一、内存结构

`InnoDB` 存储引擎的内存数据结构包括 `Buffer Pool`、`Change Buffer`、`Adaptive Hash Index` 和 `Log Buffer` 等。

### 1. Buffer Pool

当 `InnoDB` 存储引擎访问表或索引的数据时，会将这些数据缓存到主存的一块区域，这块区域被称作 `Buffer Pool`。Buffer Pool 允许那些经常被访问的数据能够直接从主存读取而不经过磁盘，这能加快数据的处理效率。在专用服务器上，通常会分配高达 80% 的物理内存给缓冲池。

了解如何利用缓冲池将频繁访问的数据保存在内存中是 `MySQL` 调优的一个重要方面。

为了提升读取大量数据的操作的效率，Buffer Pool 被划分为很多页（page），这些页可能容纳很多行数据。为了提高缓存管理的效率，Buffer Pool 整体上被实现为一条由很多页串起来的链表，同时使用 `LRU（Least Recently Used）算法` 进行缓存置换。

#### Buffer Pool 与 `LRU`

 `InnoDB` 使用 LRU 算法将 Buffer Pool 作为一条链表进行管理，当 Buffer Pool 容量不足时，最近最少被使用的的页将被驱逐出 Buffer Pool 链表，同时会将一个新的页加到 Buffer Pool 的新子链（new sublist）和旧子链（old sublist）的分界处。按我理解新子链里存放的热数据，可称为热区；旧子链存放的是待驱逐的页，可称为冷区。

![innodb-buffer-pool-list.png](./assets/innodb-buffer-pool-list.png)

这个算法使得经常被使用的页能留在新子链，而不常被访问的页将在旧子链中，旧子链中的页都是被驱逐的候选页。默认地，LRU 会如下作业：

- 3/8 的 Buffer Pool 将会划分为旧子链，5/8 的 Buffer Pool 被划分为新子链（热点数据）

- 列表的中点是新子链的尾部与旧子链的头部相交的边界

- 当 InnoDB 将一个页读入 Buffer Pool 时，会先将该页插到 Buffer Pool 的中点（旧子链的头部），这时该页能被读取到，因为它是用户指定的操作（如 SQL 查询）所必需的，或者是由 InnoDB  自动执行的预读操作的 一部分。

- 如果旧子链中的页被访问，那么它将变得年轻（young），这时会把它调到新子链的头部。这时还分情况： 如果因为用户需要而读取该页，则会立即进行第一次访问，并使页面变得年轻；如果由于预读而读取了页面，则第一次访问不会立即发生（并且在页面被逐出之前可能根本不会发生）。

  也就是说，如果是用户查询需要的数据，那么它很可能成为热点数据，但是如果只是预读需要，很可能这个数据并不会被实际需要，后面需要将之驱逐。

- 随着数据库的运行，一直没有被访问的数据页的年龄会逐渐地变大，同时在新旧子链中页面也会因为其他页面变得年轻而相对变老，另一方面，新读取的页面由于是插到旧子链的头部，所以其中的页面也会逐渐变老，最后，一直没被访问的页面会到达旧子链的尾部，最后被驱除出 Buffer Pool。

默认地，查询所需的页会在读到  Buffer Pool 的中点处后被移到新子链的头部，意味着相对来说它们可以在  Buffer Pool 中驻留久点。有些场景，比如执行 `mysqldump` 或者没有 WHERE 子句的 SELECT 操作，都会引发全表扫描 ，导致大量数据被缓存到  Buffer Pool 中，同时导致同样数量大的旧页被驱逐（假设缓存全部不命中），即使这部分缓存的新页很可能只是被访问一次。

同样地，由 InnoDB 后台线程预读的数据很可能也只是使用一次，但是它们都会被被陆续移到新子链的头部，导致真正的热点数据被刷掉。

#### Buffer Pool 热点数据集中失效问题如何解决

InnoDB 使用一种能够减少缓存到 Buffer Pool 而不会使用的数据的技术，而不是使用传统的 LRU。它的目标是确保即便遇到全表扫描或预读操作导致大量新数据块塞到 Buffer Pool  （这些数据后面再也没有被访问），那些经常被访问的热点页也能够保留在 Buffer Pool 中。

新插入的数据块会插到 Buffer Pool 的 “中点” 处，这个 “中点” 实际上是距离旧子链尾部往上 3/8 处，在该页第一次被读取时，LRU 算法会该页被插到整个 Buffer Pool 的头部，因此，对于传统的 LRU 算法而言，如果一个页一直没有被访问，那么它不可能出现在  Buffer Pool 的头部，随着缓存数据的变化，它将会老化并最终被淘汰。

你可以通过配置参数 `innodb_old_blocks_pct` 控制旧子链在整个 Buffer Pool 中所占用的比例，这个参数默认值是 37，对应我们上述的 3/8，这个参数往往在 5 到 95 之间，如果是 5，对于预读操作，这个数据很快就会老化并被淘汰；如果是 95，则只有 5% 的 Buffer Pool 用来存储热点数据，这样的算法近似传统的 LRU。

按我理解，将 `innodb_old_blocks_pct` 调得很小，从而控制冷区的空间在一个相对较小的范围，能解决预读大量无用数据的问题，但还是没解决全表查询的情况，因为默认地，这样的数据块很快就会被陆续移到新链头部，而新链放的就是热点数据，意味着热点数据还是会被刷掉。

对于全表查询，一个数据页通常被很快地访问几次（因为一页包含多行数据）然后便不会被访问了，这时可以使用另外一个叫 `innodb_old_blocks_time` 的参数，**用来指定第一次访问一个页后的时间窗口（以毫秒为单位），在这个时间窗口内，不管这个页被访问多少次，它都不会被移动到热区的顶端。** 这个参数的默认值是 1000，增大这个数值能够使得越来越多的页更快地从 Buffer Pool 中老化并被淘汰（因为延迟了它们进入热区的时间）。

`innodb_old_blocks_pct` 和 `innodb_old_blocks_time` 这两个参数都可以在配置文件 (`my.cnf` 或 `my.ini`) 中配置，或者通过 SET GLOBAL 语句进行设置。如果进行了设置后想要知道自己的设置是否生效，可以通过 `SHOW ENGINE INNODB STATUS` 命令查询当前 Buffer Pool 的情况。

由于这些参数的影响可能会根据硬件配置、数据和工作负载的细节的不同而发生很大的变化，所以在任何性能关键型或生产环境中更改这些设置之前，需要通过基准测试来验证有效性。

在混合工作负载中，大多数活动是 `OLTP` 类型的，这些活动往往伴随着列表查询，这样会导致大规模扫描，在批处理运行期间设置 `innodb_old_blocks_time` 的值可以帮助将正常工作负载的工作集保持在 Buffer Pool 中，则不刷走热区数据。

当扫描不能完全放入缓冲池的大表时，将 `innodb_old_blocks_pct` 设置为一个小值，可以避免只读取一次的数据占用缓冲池的大部分。例如，设置 `innodb_old_blocks_pct=5`，将只读取一次的数据限制为 Buffer Pool 的 5%。

当扫描小表时，如果能放到内存中，那么在 Buffer Pool 中移动页的开销会比较小，所以可以让这个值保持默认，或者可以把它调大点，比如设置 `innodb_old_blocks_pct=5`。

`innodb_old_blocks_time` 参数的影响比 `innodb_old_blocks_pct` 的更难预测，但它影响相对较小，而且这种影响会随着工作量的不同而变化，所以如果通过调整 `innodb_old_blocks_pct` 所带来的性能提升还不够，那么可以执行自己的基准测试来确定 `innodb_old_blocks_time` 的最佳值。

#### Buffer Pool 配置

可以通过调整参数来提升性能，详情见 Buffer Pool 的相关配置。

- 理想情况下，将缓冲池的大小设置为一个实用的尽可能大的值，这样服务器上的其他进程就有足够的内存运行，而不会出现过多的分页。缓冲池越大，InnoDB 就越像一个内存中的数据库，一次从磁盘读取数据，然后在后续读取时从内存中访问数据。
- 在 64 位系统中，为了减少并发操作带来的内存竞争，可以将 Buffer Pool 划分成多个实例，
- 为了避免大批量不经常访问的数据进入 Buffer Pool 后刷掉热数据，可以进行相应的配置解决。
- 因为 Buffer Pool 中的数据可能被修改而与磁盘不一致，所以需要刷盘，刷盘时可以控制后台刷新的时间以及是否根据工作负载动态调整刷新的速率。
- 可以配置 InnoDB 如何保持当前的 Buffer Pool 状态，以避免服务器重启后的漫长预热期。


#### Buffer Pool 监控

通过 `SHOW ENGINE INNODB STATUS` 命令可以看到 InnoDB 标准的监控输出，其中提供了一些关于 Buffer Pool 操作的指标。

```shell
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
```

下面是关于 Buffer Pool 的一些指标输出的描述：

|             Name             |                         Description                          |
| :--------------------------: | :----------------------------------------------------------: |
|    Total memory allocated    |         用于开辟 buffer pool 的内存大小，单位是字节          |
| Dictionary memory allocated  |        用于开辟 InnoDB 数据字典的内存大小，单位是字节        |
|       Buffer pool size       |                      buffer pool 总页数                      |
|         Free buffers         |              buffer pool 的 free list 的总页数               |
|        Database pages        |               buffer pool 的 LRU list 的总页数               |
|      Old database pages      |                    buffer pool 的冷区页数                    |
|      Modified db pages       |           buffer pool 中被修改的 LRU list 的总页数           |
|        Pending reads         |               buffer pool 中等待被读取的总页数               |
|      Pending writes LRU      |               old LRU list 底部待刷盘的脏页数                |
|  Pending writes flush list   |       checkpointing 期间 Buffer Pool 中待刷盘的总页数        |
|  Pending writes single page  | The number of pending independent page writes within the buffer pool.（看不懂） |
|       Pages made young       |                    等待被移到热区的总页数                    |
|     Pages made not young     |             保留在冷区没有变年轻（访问）的总页数             |
|           youngs/s           | 平均每秒访问 Buffer Pool 的 LRU list 的冷页并使冷页变热的次数 |
|         non-youngs/s         | 平均每秒访问 Buffer Pool 的 LRU list 的冷页但冷页不变热的次数 |
|          Pages read          |                从 buffer pool 读取到的总页数                 |
|        Pages created         |                 在 buffer pool 创建的总页数                  |
|        Pages written         |             从 buffer pool 写入（磁盘）的总页数              |
|           reads/s            |              每秒读取 Buffer Pool 页的平均次数               |
|          creates/s           |              每秒创建 Buffer Pool 页的平均次数               |
|           writes/s           |              每秒写入 Buffer Pool 页的平均次数               |
|     Buffer pool hit rate     | 从 Buffer Pool 读取页面与从磁盘存储读取页面的缓冲池页面命中率。 |
|      young-making rate       |               页面访问导致页变年轻的平均命中率               |
|   not (young-making rate)    |              页面访问不导致页变年轻的平均命中率              |
|       Pages read ahead       |                       平均每秒预读次数                       |
| Pages evicted without access |         buffer pool 中平均每秒因未被访问而被驱逐页数         |
|      Random read ahead       |                     平均每秒随机预读次数                     |
|           LRU len            |               buffer pool 中 LRU list 的总页数               |
|        unzip_LRU len         |          buffer pool 中 加压缩 的 LRU list 的总页数          |
|           I/O sum            |            buffer pool 中的 LRU list 被访问的页数            |
|           I/O cur            |                 LRU list 中当前被访问的页数                  |
|        I/O unzip sum         |                unzip_LRU list 解压缩的总页数                 |
|        I/O unzip cur         |           unzip_LRU list 当前时间段解压缩的总页数            |

在上面的参数中，可以重点关注下面这几个

- `youngs/s`：仅用于描述旧页，它基于访问页面的次数。一个给定页面可以有多次访问，所有访问都将被计算。young 表示被访问并且成为热区数据，即描述单位时间内，页被访问并且变 young 的次数。如果在没有大规模扫描的情况下会看到 young /s 是一个非常低的值，可以考虑减少冷区页变热的延时时间或者增大冷区在整个 Buffer Pool 的 LRU list 中的比例，从而使该冷区中的页移动到尾部需要更长的时间，这能增加再次访问这些页并使其变为年轻页的可能性（因为没有全表扫描，这些页很可能被再次访问）。
- `non-youngs/s`：仅用于描述旧页，它基于访问页面的次数。一个给定页面可以有多次访问，所有访问都将被计算。non-young 表示被访问但是不会成为热区数据（因为设置了 `innodb_old_blocks_time`），即描述单位时间内，页被访问但没变 young 的次数。如果这个数值很高，一般情况下是因为系统存在严重的全表扫描，并且 `innodb_old_blocks_time` 设置得足够大。反过来，如果你正在执行全表扫描，但是没有看到这个值变大，或者看到 `youngs/s` 变大，说明延时设置不够大，可能会把大量热区数据刷掉，所以要把 `innodb_old_blocks_time` 调大。
- `young-making rate`：表示了 Buffer Pool 中所有页变年轻的访问次数，而不仅仅是冷区页，`young-making rate `和 `not (young-making rate)` 加起来不一定等于整个 Buffer Pool 的命中率，冷区页的命中会导致页面移至热区，但是热区页的命中只有在页本身与热区头部间有一定距离才会移至热区头部（即如果命中本身就是热区头部将不会变年轻吗？）
-  `not (young-making rate)` ：同样表示 Buffer Pool 中所有页的访问情况，而不仅局限于冷区页。由于设置了 `innodb_old_blocks_time` ，所以这时对冷区页的访问并不会使它们变年轻而移到热区，这个参数就表示这种访问的比例，当然热区数据被访问也不一定移到热区头部（类似上一个参数？命中本身就是热区头部？）

### 2. Change Buffer

Change Buffer 是一种特殊的数据结构，用于在二级索引页不在 Buffer Pool 中时将对二级索引页更改缓存起来。Change Buffer 中记录的索引页变更，可能由 INSERT，UPDATE 或 DELETE 操作（DML）导致，如果在以后有其他读取操作将相应的索引页加载到 Buffer Pool 时，Change Buffer 中的数据将会与之合并。

![innodb-change-buffer.png](./assets/innodb-change-buffer.png)

不同于聚簇索引，二级索引通常都是非唯一的，往二级索引插入页的顺序是随机的，同样地，删除和更新会影响不相邻的二级索引页 q

