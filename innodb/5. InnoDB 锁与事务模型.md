 
# 一、InnoDB 锁操作

## 1. 共享锁和排他锁

InnoDB 实现了标准的行级锁（row-level locking），行级锁有两种，分别是共享锁（Shared Locks，S 锁）和排他锁（Exclusive Locks，X 锁）。

- 如果某个行加了共享锁，则一个事务要读取该行，需要先拿到共享锁。
- 如果某个行加了共享锁，则一个事务要更新或删除该行，需要先拿到排他锁。

如果一个事务 T1 拿到了某个行 r 上的 S 锁，则 InnoDB 对另一个不同的事务 T2 对 r 上的锁请求的处理如下：

- 如果 T2 请求的是 S 锁，则 InnoDB 会立马允许它拿到该 S 锁，因此，T1 和 T2 都持有对 r 的 S 锁。
- 如果 T2 请求的是 X 锁，则 InnoDB 不会立马允许它拿到该 X 锁，因为 X 锁是事务独占式的，T2 需要等待 T1 释放该 X 锁才有机会拿到它。

如果一个事务 T1 拿到了某个行 r 上的 X 锁，则不管另一个不同的事务 T2 向 InnoDB 请求 r 上的哪种类型的锁都不会被立马许可，T2 需要等待 T1 释放该 X 锁。

## 2. 意向锁

InnoDB 支持多种粒度锁定机制（Intention Locking），这允许行锁和表锁并存。例如，`LOCK TABLES ... WRITE` 语句在指定表上设置排他锁（X 锁）。为了使在多个粒度级别上的锁定变得切实可行，InnoDB 引入了意图锁。意向锁是表级锁，它能指示事务稍后对表中的行需要哪种类型的锁（共享锁或排他锁）。有两种类型的意图锁：

1. 意向共享锁（Intention Shared Lock，IS 锁）：表明事务打算表中各个行设置一个共享锁。
2. 意向排他锁（Intention Exclusive Lock，IX 锁）：表明事务打算表中各个行设置一个排他锁。

例如，`SELECT ... LOCK IN SHARE MODE` 语句设置一个 IS 锁，`SELECT ... FOR UPDATE` 语句设置一个 IX 锁。意向锁的协议如下：

- 在事务可以获取表中某行上的共享锁之前，它必须首先获取该表上的 IS 锁或更高级别的锁。
- 在事务可以获取表中某行的排它锁之前，它必须首先获取该表中的 IX 锁。

表级别的锁类型兼容性如下总结表所示：

|      | `X`  | `IX` | `S`  | `IS` |
| :--: | :--: | :--: | :--: | :--: |
| `X`  | 冲突 | 冲突 | 冲突 | 冲突 |
| `IX` | 冲突 | 兼容 | 冲突 | 兼容 |
| `S`  | 冲突 | 冲突 | 兼容 | 兼容 |
| `IS` | 冲突 | 兼容 | 兼容 | 兼容 |

如果锁与现有锁兼容，则将其授予给请求的事务，但如果与现有锁冲突，则不授予该请求。事务要等待直到冲突的现有锁被释放。如果锁请求与现有的锁发生冲突，并且可能因为被授予锁而导致死锁所以无法被授予许可 ，则会抛出错误。

意向锁不会阻止除全表请求（例如 LOCK TABLES ... WRITE）以外的任何内容。意图锁的主要目的是表明有人正在或者将要锁定表中的行。

通过 SHOW ENGINE INNODB STATUS 看到的输出可见意向锁的事务数据与下面所示的内容结构大同小异：

```mysql
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```

## 3. 记录锁

一个记录锁（Record Lock）是对一个索引记录上加的锁，如 `SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE` 语句，可以防止另一个事务插入、更新或删除 t.c1 上值为 10 的行。

记录锁总是锁住索引记录，即使表没有定义索引（对于这样的情况，InnoDB 创建一个隐藏的聚簇索引，然后加这个索引上加锁）。

通过 SHOW ENGINE INNODB STATUS 看到的输出可见记录锁的事务数据与下面所示的内容结构大同小异：

```mysql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```

## 4. 间隙锁

一个间隙锁用于对索引记录之间的间隙进行锁定，或者是对第一个索引记录之前的或最后一个索引记录之后的的间隙的锁定。例如，对于 `SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;` 语句，能避免其他事务插入在 t.c1 列插入一个值为 10 的数据，不管这个列中是否已经存在这么一个值，因为这个范围里面的所有已经存在的值之间的间隙已经被锁定了。

这里的间隙可能跨越索引上单个值、索引上的多个值、或者为空也有可能。

间隙锁是性能和并发性之间的一种权衡，并且在某些指定的事务隔离级别中使用。

没有必要在唯一索引上加间隙锁来锁定很多行以找到某个唯一行（对于多列唯一索引，如果走了覆盖索引的机制，那么间隙锁是有效的）。例如，如果某表的 id 列具有唯一索引，则以下语句仅对这个索引上 id 值为 100 的行进行锁定，并且不用关心其他会话是否在前面的间隙中插入行：

```mysql
SELECT * FROM child WHERE id = 100;
```

如果 id 未建立索引或具有非唯一索引，则该语句会锁定前面的间隙。

在这里还值得注意的是，不同的事务可以在间隙上持有冲突的锁。例如，事务 A 可以在间隙上持有一个共享的间隙锁（间隙 S 锁），与此同时事务 B 可以在同一间隙上持有排他的间隙锁（间隙 X 锁）。允许冲突的间隙锁的原因是，如果一个记录从索引中被清除，则必须合并由不同事务在该记录上持有的间隙锁。

InnoDB 的间隙锁是 “纯粹抑制性的”，这意味着这类锁的唯一目的是防止其他事务在间隙中插入数据。间隙锁可以共存。一个事务对某个间隙加的锁不会阻止另一事务对相同的间隙进行锁定。因此共享间隙锁和排他间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。

可以显式禁用间隙锁。如果将事务隔离级别更改为 READ COMMITTED 或启用 `innodb_locks_unsafe_for_binlog` 系统变量（现在已弃用），则会发生这种情况。在这种情况下，搜索和索引扫描将不会用到间隙锁，间隙锁将仅被用于外键约束检查（foreign-key constraint checking）和重复键检查（duplicate-key checking）。

使用 READ COMMITTED 隔离级别或启用 innodb_locks_unsafe_for_binlog 还具有其他效果。MySQL 在评估 WHERE 条件后，将释放不匹配行的记录锁。对于 UPDATE 语句，InnoDB 执行 `半一致读（semi-consistent read）`，以便将最新的提交版本返回给 MySQL，这样 MySQL 可以确定该行是否与 WHERE 条件匹配的将要 UPDATE 的行。

# 参考

- https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html

